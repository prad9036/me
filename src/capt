#!/usr/bin/env python3
import os
import sys
import subprocess
import tempfile
import shutil
import json
from pathlib import Path

# Directories
CAPT_DIR = Path.home() / ".capt"
CAPT_BIN_DIR = CAPT_DIR / "bin"
CAPT_MANIFEST = CAPT_DIR / "installed.json"
CAPT_LIB_PATHS_FILE = CAPT_DIR / ".ld_paths"
CAPT_SOURCE_FILE = CAPT_DIR / ".source_me"
BASHRC_PATH = Path.home() / ".bashrc"


# -------------------------------
# Utilities
# -------------------------------
def run_command(command, cwd=None, check=True):
    """Run a shell command and return the completed process."""
    try:
        return subprocess.run(
            command, shell=True, check=check,
            capture_output=True, text=True, cwd=cwd
        )
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] Command failed: {command}")
        if e.stdout:
            print(f"STDOUT:\n{e.stdout}")
        if e.stderr:
            print(f"STDERR:\n{e.stderr}")
        if check:
            sys.exit(1)
        return e


def load_manifest():
    if CAPT_MANIFEST.exists():
        return json.loads(CAPT_MANIFEST.read_text())
    return {}


def save_manifest(data):
    CAPT_MANIFEST.parent.mkdir(parents=True, exist_ok=True)
    CAPT_MANIFEST.write_text(json.dumps(data, indent=2))


# -------------------------------
# Env / Shell Config
# -------------------------------
def update_library_paths():
    """Scan ~/.capt for .so files and regenerate LD_LIBRARY_PATH config."""
    if not CAPT_DIR.exists():
        return

    lib_dirs = {str(p.parent.resolve()) for p in CAPT_DIR.rglob("*.so*") if p.is_file()}

    with open(CAPT_LIB_PATHS_FILE, "w") as f:
        for d in sorted(lib_dirs):
            f.write(d + "\n")

    with open(CAPT_SOURCE_FILE, "w") as f:
        f.write("# Auto-generated by capt. Do not edit.\n")
        if lib_dirs:
            ld_path_str = ":".join(sorted(lib_dirs))
            f.write(f'export LD_LIBRARY_PATH="{ld_path_str}:${{LD_LIBRARY_PATH}}"\n')


def ensure_shell_config():
    """Ensure ~/.bashrc sources CAPT paths."""
    CAPT_BIN_DIR.mkdir(parents=True, exist_ok=True)
    bin_path_line = f'export PATH="{CAPT_BIN_DIR}:$PATH"'
    source_line = f'if [ -f "{CAPT_SOURCE_FILE}" ]; then source "{CAPT_SOURCE_FILE}"; fi'

    try:
        content = BASHRC_PATH.read_text()
    except FileNotFoundError:
        content = ""

    changed = False
    if bin_path_line not in content:
        content += f"\n# Added by CAPT\n{bin_path_line}\n"
        changed = True
    if source_line not in content:
        content += f"# Added by CAPT\n{source_line}\n"
        changed = True

    if changed:
        BASHRC_PATH.write_text(content)
        print(f"[INFO] Updated {BASHRC_PATH}, run: source {BASHRC_PATH}")


# -------------------------------
# Dependency Handling
# -------------------------------
def get_dependencies(pkg):
    """Return a list of package dependencies using apt-cache."""
    result = run_command(f"apt-cache depends {pkg}", check=False)
    deps = []
    for line in result.stdout.splitlines():
        line = line.strip()
        if line.startswith("Depends:"):
            dep = line.split(":", 1)[1].strip()
            if not dep.startswith("<"):  # ignore virtual packages
                deps.append(dep)
    return deps


# -------------------------------
# Package Management
# -------------------------------
def extract_deb(deb_file, target_dir):
    """Extract a .deb into ~/.capt and return list of extracted files."""
    extracted_files = []
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)
        shutil.copy(deb_file, temp_path)
        deb_name = Path(deb_file).name

        run_command(f"ar -x {deb_name}", cwd=temp_path)
        data_archive = next(temp_path.glob("data.tar.*"), None)
        if not data_archive:
            print(f"[ERROR] Could not find data archive in {deb_file}")
            sys.exit(1)

        if data_archive.suffix == ".zst":
            if not shutil.which("zstd"):
                install_package("zstd", is_dependency=True)
            extract_cmd = f"zstd -dc '{data_archive}' | tar -tf -"
            extract_cmd2 = f"zstd -dc '{data_archive}' | tar -xf - -C '{target_dir}'"
        elif data_archive.suffix == ".xz":
            if not shutil.which("xz"):
                install_package("xz", is_dependency=True)
            extract_cmd = f"xz -dc '{data_archive}' | tar -tf -"
            extract_cmd2 = f"xz -dc '{data_archive}' | tar -xf - -C '{target_dir}'"
        else:
            extract_cmd = f"tar -tf '{data_archive}'"
            extract_cmd2 = f"tar -xf '{data_archive}' -C '{target_dir}'"

        # List files
        out = run_command(extract_cmd, cwd=temp_path)
        extracted_files = [str(target_dir / f) for f in out.stdout.splitlines()]

        # Extract
        run_command(extract_cmd2, cwd=temp_path)

    return extracted_files


def install_package(pkg, is_dependency=False, installed=None):
    """Install a package (and its dependencies) into ~/.capt."""
    if installed is None:
        installed = set()

    manifest = load_manifest()
    if pkg in manifest:
        return  # already installed

    if pkg in installed:
        return
    installed.add(pkg)

    if not is_dependency:
        print(f"[INFO] Installing {pkg}...")

    ensure_shell_config()

    # Step 1: Resolve dependencies
    deps = get_dependencies(pkg)
    for dep in deps:
        install_package(dep, is_dependency=True, installed=installed)

    # Step 2: Download the .deb (try apt first, fallback to apt-get)
    with tempfile.TemporaryDirectory() as tmp:
        try:
            run_command(f"apt -y download {pkg}", cwd=tmp)
        except SystemExit:
            run_command(f"apt-get -y download {pkg}", cwd=tmp)

        debs = list(Path(tmp).glob("*.deb"))
        if not debs:
            print(f"[ERROR] Could not download .deb for {pkg}")
            sys.exit(1)

        # Step 3: Extract it
        files = extract_deb(debs[0], CAPT_DIR)

        # Step 4: Link executables
        linked_bins = []
        for exe in (CAPT_DIR / "usr" / "bin").glob("*"):
            dest = CAPT_BIN_DIR / exe.name
            if not dest.exists():
                os.symlink(exe, dest)
                linked_bins.append(str(dest))

    update_library_paths()

    # Step 5: Save to manifest
    manifest[pkg] = {
        "files": files,
        "bins": linked_bins,
        "deps": deps,
    }
    save_manifest(manifest)

    if not is_dependency:
        print(f"[SUCCESS] Installed {pkg}")
        print(f"         Run 'source {BASHRC_PATH}' or restart your shell.")


def remove_package(pkg):
    manifest = load_manifest()
    if pkg not in manifest:
        print(f"[INFO] {pkg} is not installed.")
        return

    print(f"[INFO] Removing {pkg}...")
    pkg_data = manifest[pkg]

    # Remove symlinks
    for b in pkg_data.get("bins", []):
        try:
            Path(b).unlink()
        except FileNotFoundError:
            pass

    # Remove files
    for f in pkg_data.get("files", []):
        p = Path(f)
        try:
            if p.is_symlink() or p.is_file():
                p.unlink()
        except FileNotFoundError:
            pass

    # Remove empty directories (bottom-up)
    for f in pkg_data.get("files", []):
        p = Path(f)
        while p != CAPT_DIR and p.exists():
            try:
                p.rmdir()  # only removes empty dirs
            except OSError:
                break
            p = p.parent

    # Update manifest
    del manifest[pkg]
    save_manifest(manifest)
    update_library_paths()
    print(f"[SUCCESS] Removed {pkg}")


# -------------------------------
# Commands
# -------------------------------
def show_help():
    print("""capt - mini package manager in ~/.capt

Usage:
  capt install <pkg>   Install a package
  capt remove <pkg>    Uninstall a package
  capt list            List installed packages
  capt info <pkg>      Show info about a package
  capt help            Show this help
""")


def list_packages():
    manifest = load_manifest()
    if not manifest:
        print("No packages installed.")
        return
    for pkg in manifest.keys():
        print(pkg)


def info_package(pkg):
    manifest = load_manifest()
    if pkg not in manifest:
        print(f"{pkg} is not installed.")
        return
    data = manifest[pkg]
    print(json.dumps(data, indent=2))


# -------------------------------
# Main
# -------------------------------
def main():
    os.environ["PATH"] = f"{CAPT_BIN_DIR}:{os.environ['PATH']}"
    if len(sys.argv) < 2:
        show_help()
        sys.exit(1)

    cmd = sys.argv[1]

    if cmd == "install" and len(sys.argv) >= 3:
        install_package(sys.argv[2])
    elif cmd == "remove" and len(sys.argv) >= 3:
        remove_package(sys.argv[2])
    elif cmd == "list":
        list_packages()
    elif cmd == "info" and len(sys.argv) >= 3:
        info_package(sys.argv[2])
    elif cmd == "help":
        show_help()
    else:
        show_help()
        sys.exit(1)


if __name__ == "__main__":
    main()
